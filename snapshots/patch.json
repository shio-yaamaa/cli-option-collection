[
  {
    "name": "patch",
    "options": [
      {
        "type": "short",
        "key": "B",
        "title": "-B backup-prefix, --prefix backup-prefix",
        "description": "Causes the next argument to be interpreted as a prefix to the backup file name. If this argument is specified, any argument to -z will be ignored."
      },
      {
        "type": "long",
        "key": "prefix",
        "title": "-B backup-prefix, --prefix backup-prefix",
        "description": "Causes the next argument to be interpreted as a prefix to the backup file name. If this argument is specified, any argument to -z will be ignored."
      },
      {
        "type": "short",
        "key": "b",
        "title": "-b, --backup",
        "description": "Save a backup copy of the file before it is modified. By default the original file is saved with a backup extension of \".orig\" unless the file already has a numbered backup, in which case a numbered backup is made. This is equivalent to specifying \"-V existing\". This option is currently the default, unless --posix is specified."
      },
      {
        "type": "long",
        "key": "backup",
        "title": "-b, --backup",
        "description": "Save a backup copy of the file before it is modified. By default the original file is saved with a backup extension of \".orig\" unless the file already has a numbered backup, in which case a numbered backup is made. This is equivalent to specifying \"-V existing\". This option is currently the default, unless --posix is specified."
      },
      {
        "type": "short",
        "key": "C",
        "title": "-C, --check, --dry-run",
        "description": "Checks that the patch would apply cleanly, but does not modify anything."
      },
      {
        "type": "long",
        "key": "check",
        "title": "-C, --check, --dry-run",
        "description": "Checks that the patch would apply cleanly, but does not modify anything."
      },
      {
        "type": "long",
        "key": "dry-run",
        "title": "-C, --check, --dry-run",
        "description": "Checks that the patch would apply cleanly, but does not modify anything."
      },
      {
        "type": "short",
        "key": "c",
        "title": "-c, --context",
        "description": "Forces patch to interpret the patch file as a context diff."
      },
      {
        "type": "long",
        "key": "context",
        "title": "-c, --context",
        "description": "Forces patch to interpret the patch file as a context diff."
      },
      {
        "type": "short",
        "key": "D",
        "title": "-D symbol, --ifdef symbol",
        "description": "Causes patch to use the \"#ifdef...#endif\" construct to mark changes. The argument following will be used as the differentiating symbol. Note that, unlike the C compiler, there must be a space between the -D and the argument."
      },
      {
        "type": "long",
        "key": "ifdef",
        "title": "-D symbol, --ifdef symbol",
        "description": "Causes patch to use the \"#ifdef...#endif\" construct to mark changes. The argument following will be used as the differentiating symbol. Note that, unlike the C compiler, there must be a space between the -D and the argument."
      },
      {
        "type": "short",
        "key": "d",
        "title": "-d directory, --directory directory",
        "description": "Causes patch to interpret the next argument as a directory, and change working directory to it before doing anything else."
      },
      {
        "type": "long",
        "key": "directory",
        "title": "-d directory, --directory directory",
        "description": "Causes patch to interpret the next argument as a directory, and change working directory to it before doing anything else."
      },
      {
        "type": "short",
        "key": "E",
        "title": "-E, --remove-empty-files",
        "description": "Causes patch to remove output files that are empty after the patches have been applied. This option is useful when applying patches that create or remove files."
      },
      {
        "type": "long",
        "key": "remove-empty-files",
        "title": "-E, --remove-empty-files",
        "description": "Causes patch to remove output files that are empty after the patches have been applied. This option is useful when applying patches that create or remove files."
      },
      {
        "type": "short",
        "key": "e",
        "title": "-e, --ed",
        "description": "Forces patch to interpret the patch file as an ed(1) script."
      },
      {
        "type": "long",
        "key": "ed",
        "title": "-e, --ed",
        "description": "Forces patch to interpret the patch file as an ed(1) script."
      },
      {
        "type": "short",
        "key": "F",
        "title": "-F max-fuzz, --fuzz max-fuzz",
        "description": "Sets the maximum fuzz factor. This option only applies to context diffs, and causes patch to ignore up to that many lines in looking for places to install a hunk. Note that a larger fuzz factor increases the odds of a faulty patch. The default fuzz factor is 2, and it may not be set to more than the number of lines of context in the context diff, ordinarily 3."
      },
      {
        "type": "long",
        "key": "fuzz",
        "title": "-F max-fuzz, --fuzz max-fuzz",
        "description": "Sets the maximum fuzz factor. This option only applies to context diffs, and causes patch to ignore up to that many lines in looking for places to install a hunk. Note that a larger fuzz factor increases the odds of a faulty patch. The default fuzz factor is 2, and it may not be set to more than the number of lines of context in the context diff, ordinarily 3."
      },
      {
        "type": "short",
        "key": "f",
        "title": "-f, --force",
        "description": "Forces patch to assume that the user knows exactly what he or she is doing, and to not ask any questions. It assumes the following: skip patches for which a file to patch can't be found; patch files even though they have the wrong version for the \"Prereq:\" line in the patch; and assume that patches are not reversed even if they look like they are. This option does not suppress commentary; use -s for that."
      },
      {
        "type": "long",
        "key": "force",
        "title": "-f, --force",
        "description": "Forces patch to assume that the user knows exactly what he or she is doing, and to not ask any questions. It assumes the following: skip patches for which a file to patch can't be found; patch files even though they have the wrong version for the \"Prereq:\" line in the patch; and assume that patches are not reversed even if they look like they are. This option does not suppress commentary; use -s for that."
      },
      {
        "type": "short",
        "key": "i",
        "title": "-i patchfile, --input patchfile",
        "description": "Causes the next argument to be interpreted as the input file name (i.e. a patchfile). This option may be specified multiple times."
      },
      {
        "type": "long",
        "key": "input",
        "title": "-i patchfile, --input patchfile",
        "description": "Causes the next argument to be interpreted as the input file name (i.e. a patchfile). This option may be specified multiple times."
      },
      {
        "type": "short",
        "key": "l",
        "title": "-l, --ignore-whitespace",
        "description": "Causes the pattern matching to be done loosely, in case the tabs and spaces have been munged in your input file. Any sequence of whitespace in the pattern line will match any sequence in the input file. Normal characters must still match exactly. Each line of the context must still match a line in the input file."
      },
      {
        "type": "long",
        "key": "ignore-whitespace",
        "title": "-l, --ignore-whitespace",
        "description": "Causes the pattern matching to be done loosely, in case the tabs and spaces have been munged in your input file. Any sequence of whitespace in the pattern line will match any sequence in the input file. Normal characters must still match exactly. Each line of the context must still match a line in the input file."
      },
      {
        "type": "short",
        "key": "N",
        "title": "-N, --forward",
        "description": "Causes patch to ignore patches that it thinks are reversed or already applied. See also -R."
      },
      {
        "type": "long",
        "key": "forward",
        "title": "-N, --forward",
        "description": "Causes patch to ignore patches that it thinks are reversed or already applied. See also -R."
      },
      {
        "type": "short",
        "key": "n",
        "title": "-n, --normal",
        "description": "Forces patch to interpret the patch file as a normal diff."
      },
      {
        "type": "long",
        "key": "normal",
        "title": "-n, --normal",
        "description": "Forces patch to interpret the patch file as a normal diff."
      },
      {
        "type": "short",
        "key": "o",
        "title": "-o out-file, --output out-file",
        "description": "Causes the next argument to be interpreted as the output file name."
      },
      {
        "type": "long",
        "key": "output",
        "title": "-o out-file, --output out-file",
        "description": "Causes the next argument to be interpreted as the output file name."
      },
      {
        "type": "short",
        "key": "p",
        "title": "-p strip-count, --strip strip-count",
        "description": "Sets the pathname strip count, which controls how pathnames found in the patch file are treated, in case you keep your files in a different directory than the person who sent out the patch. The strip count specifies how many slashes are to be stripped from the front of the pathname. (Any intervening directory names also go away.) For example, supposing the file name in the patch file was /u/howard/src/blurfl/blurfl.c:\n\nSetting -p0 gives the entire pathname unmodified.\n\n-p1 gives\n\n\n\nu/howard/src/blurfl/blurfl.c\n\nwithout the leading slash.\n\n-p4 gives\n\n\n\nblurfl/blurfl.c\n\nNot specifying -p at all just gives you blurfl.c, unless all of the directories in the leading path (u/howard/src/blurfl) exist and that path is relative, in which case you get the entire pathname unmodified. Whatever you end up with is looked for either in the current directory, or the directory specified by the -d option."
      },
      {
        "type": "long",
        "key": "strip",
        "title": "-p strip-count, --strip strip-count",
        "description": "Sets the pathname strip count, which controls how pathnames found in the patch file are treated, in case you keep your files in a different directory than the person who sent out the patch. The strip count specifies how many slashes are to be stripped from the front of the pathname. (Any intervening directory names also go away.) For example, supposing the file name in the patch file was /u/howard/src/blurfl/blurfl.c:\n\nSetting -p0 gives the entire pathname unmodified.\n\n-p1 gives\n\n\n\nu/howard/src/blurfl/blurfl.c\n\nwithout the leading slash.\n\n-p4 gives\n\n\n\nblurfl/blurfl.c\n\nNot specifying -p at all just gives you blurfl.c, unless all of the directories in the leading path (u/howard/src/blurfl) exist and that path is relative, in which case you get the entire pathname unmodified. Whatever you end up with is looked for either in the current directory, or the directory specified by the -d option."
      },
      {
        "type": "short",
        "key": "R",
        "title": "-R, --reverse",
        "description": "Tells patch that this patch was created with the old and new files swapped. (Yes, I'm afraid that does happen occasionally, human nature being what it is.) patch will attempt to swap each hunk around before applying it. Rejects will come out in the swapped format. The -R option will not work with ed diff scripts because there is too little information to reconstruct the reverse operation.\n\nIf the first hunk of a patch fails, patch will reverse the hunk to see if it can be applied that way. If it can, you will be asked if you want to have the -R option set. If it can't, the patch will continue to be applied normally. (Note: this method cannot detect a reversed patch if it is a normal diff and if the first command is an append (i.e. it should have been a delete) since appends always succeed, due to the fact that a null context will match anywhere. Luckily, most patches add or change lines rather than delete them, so most reversed normal diffs will begin with a delete, which will fail, triggering the heuristic.)"
      },
      {
        "type": "long",
        "key": "reverse",
        "title": "-R, --reverse",
        "description": "Tells patch that this patch was created with the old and new files swapped. (Yes, I'm afraid that does happen occasionally, human nature being what it is.) patch will attempt to swap each hunk around before applying it. Rejects will come out in the swapped format. The -R option will not work with ed diff scripts because there is too little information to reconstruct the reverse operation.\n\nIf the first hunk of a patch fails, patch will reverse the hunk to see if it can be applied that way. If it can, you will be asked if you want to have the -R option set. If it can't, the patch will continue to be applied normally. (Note: this method cannot detect a reversed patch if it is a normal diff and if the first command is an append (i.e. it should have been a delete) since appends always succeed, due to the fact that a null context will match anywhere. Luckily, most patches add or change lines rather than delete them, so most reversed normal diffs will begin with a delete, which will fail, triggering the heuristic.)"
      },
      {
        "type": "short",
        "key": "r",
        "title": "-r rej-name, --reject-file rej-name",
        "description": "Causes the next argument to be interpreted as the reject file name."
      },
      {
        "type": "long",
        "key": "reject-file",
        "title": "-r rej-name, --reject-file rej-name",
        "description": "Causes the next argument to be interpreted as the reject file name."
      },
      {
        "type": "short",
        "key": "s",
        "title": "-s, --quiet, --silent",
        "description": "Makes patch do its work silently, unless an error occurs."
      },
      {
        "type": "long",
        "key": "quiet",
        "title": "-s, --quiet, --silent",
        "description": "Makes patch do its work silently, unless an error occurs."
      },
      {
        "type": "long",
        "key": "silent",
        "title": "-s, --quiet, --silent",
        "description": "Makes patch do its work silently, unless an error occurs."
      },
      {
        "type": "short",
        "key": "t",
        "title": "-t, --batch",
        "description": "Similar to -f, in that it suppresses questions, but makes some different assumptions: skip patches for which a file to patch can't be found (the same as -f); skip patches for which the file has the wrong version for the \"Prereq:\" line in the patch; and assume that patches are reversed if they look like they are."
      },
      {
        "type": "long",
        "key": "batch",
        "title": "-t, --batch",
        "description": "Similar to -f, in that it suppresses questions, but makes some different assumptions: skip patches for which a file to patch can't be found (the same as -f); skip patches for which the file has the wrong version for the \"Prereq:\" line in the patch; and assume that patches are reversed if they look like they are."
      },
      {
        "type": "short",
        "key": "u",
        "title": "-u, --unified",
        "description": "Forces patch to interpret the patch file as a unified context diff (a unidiff)."
      },
      {
        "type": "long",
        "key": "unified",
        "title": "-u, --unified",
        "description": "Forces patch to interpret the patch file as a unified context diff (a unidiff)."
      },
      {
        "type": "short",
        "key": "V",
        "title": "-V t | nil | never, --version-control t | nil | never",
        "description": "Causes the next argument to be interpreted as a method for creating backup file names. The type of backups made can also be given in the PATCH_VERSION_CONTROL or VERSION_CONTROL environment variables, which are overridden by this option. The -B option overrides this option, causing the prefix to always be used for making backup file names. The values of the PATCH_VERSION_CONTROL and VERSION_CONTROL environment variables and the argument to the -V option are like the GNU Emacs “version-control” variable; they also recognize synonyms that are more descriptive. The valid values are (unique abbreviations are accepted):\nt, numbered Always make numbered backups. nil, existing Make numbered backups of files that already have them, simple backups of the others. never, simple Always make simple backups."
      },
      {
        "type": "long",
        "key": "version-control",
        "title": "-V t | nil | never, --version-control t | nil | never",
        "description": "Causes the next argument to be interpreted as a method for creating backup file names. The type of backups made can also be given in the PATCH_VERSION_CONTROL or VERSION_CONTROL environment variables, which are overridden by this option. The -B option overrides this option, causing the prefix to always be used for making backup file names. The values of the PATCH_VERSION_CONTROL and VERSION_CONTROL environment variables and the argument to the -V option are like the GNU Emacs “version-control” variable; they also recognize synonyms that are more descriptive. The valid values are (unique abbreviations are accepted):\nt, numbered Always make numbered backups. nil, existing Make numbered backups of files that already have them, simple backups of the others. never, simple Always make simple backups."
      },
      {
        "type": "short",
        "key": "v",
        "title": "-v, --version",
        "description": "Causes patch to print out its revision header and patch level."
      },
      {
        "type": "long",
        "key": "version",
        "title": "-v, --version",
        "description": "Causes patch to print out its revision header and patch level."
      },
      {
        "type": "short",
        "key": "x",
        "title": "-x number, --debug number",
        "description": "Sets internal debugging flags, and is of interest only to patch patchers."
      },
      {
        "type": "long",
        "key": "debug",
        "title": "-x number, --debug number",
        "description": "Sets internal debugging flags, and is of interest only to patch patchers."
      },
      {
        "type": "short",
        "key": "z",
        "title": "-z backup-ext, --suffix backup-ext",
        "description": "Causes the next argument to be interpreted as the backup extension, to be used in place of \".orig\"."
      },
      {
        "type": "long",
        "key": "suffix",
        "title": "-z backup-ext, --suffix backup-ext",
        "description": "Causes the next argument to be interpreted as the backup extension, to be used in place of \".orig\"."
      },
      {
        "type": "long",
        "key": "posix",
        "title": "--posix",
        "description": "Enables strict IEEE Std 1003.1-2008 (“POSIX.1”) conformance, specifically:\n 1. Backup files are not created unless the -b option is specified.\n 2. If unspecified, the file name used is the first of the old, new and index files that exists."
      }
    ]
  }
]
