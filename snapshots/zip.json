[
  {
    "name": "zip",
    "optionStyle": "short-and-long",
    "options": [
      {
        "key": "a",
        "title": "-a, --ascii",
        "description": "[Systems using EBCDIC] Translate file to ASCII format."
      },
      {
        "key": "ascii",
        "title": "-a, --ascii",
        "description": "[Systems using EBCDIC] Translate file to ASCII format."
      },
      {
        "key": "A",
        "title": "-A, --adjust-sfx",
        "description": "Adjust self-extracting executable  archive.   A  self-extracting executable  archive  is created by prepending the SFX stub to an existing archive. The -A option tells zip to  adjust  the  entry offsets  stored in the archive to take into account this \"pream- ble\" data."
      },
      {
        "key": "adjust-sfx",
        "title": "-A, --adjust-sfx",
        "description": "Adjust self-extracting executable  archive.   A  self-extracting executable  archive  is created by prepending the SFX stub to an existing archive. The -A option tells zip to  adjust  the  entry offsets  stored in the archive to take into account this \"pream- ble\" data."
      },
      {
        "key": "archive-clear",
        "title": "-AC, --archive-clear",
        "description": "[WIN32]   Once  archive  is  created  (and tested if -T is used, which is recommended), clear the  archive  bits  of  files  pro- cessed.   WARNING:  Once  the bits are cleared they are cleared. You may want to use the -sf show files option to store the  list of  files  processed  in  case the archive operation must be re- peated.  Also consider using the -MM must match option.  Be sure to  check  out  -DF  as  a possibly better way to do incremental backups."
      },
      {
        "key": "archive-set",
        "title": "-AS, --archive-set",
        "description": "[WIN32]  Only include files that have the archive bit set.   Di- rectories are not stored when -AS is used, though by default the paths of entries, including directories, are stored as usual and can be used by most unzips to recreate directories. The  archive  bit  is set by the operating system when a file is modified and, if used with -AC, -AS can provide  an  incremental backup  capability.   However, other applications can modify the archive bit and it may not be  a  reliable  indicator  of  which files  have  changed since the last archive operation.  Alterna- tive ways to create incremental backups are using -t to use file dates,  though  this won't catch old files copied to directories being archived, and -DF to create a differential archive."
      },
      {
        "key": "B",
        "title": "-B, --binary",
        "description": "[VM/CMS and MVS] force file to be read binary (default is text)."
      },
      {
        "key": "binary",
        "title": "-B, --binary",
        "description": "[VM/CMS and MVS] force file to be read binary (default is text)."
      },
      {
        "key": "b",
        "title": "-b path, --temp-path path",
        "description": "Use the specified path for the temporary zip archive. For  exam- ple:        zip -b /tmp stuff * will  put the temporary zip archive in the directory /tmp, copy- ing over stuff.zip to the current directory when done. This  op- tion  is  useful  when updating an existing archive and the file system containing this old archive does not have enough space to hold both old and new archives at the same time.  It may also be useful when streaming in some cases to avoid the need  for  data descriptors.   Note  that using this option may require zip take additional time to copy the archive file when done to the desti- nation file system."
      },
      {
        "key": "temp-path",
        "title": "-b path, --temp-path path",
        "description": "Use the specified path for the temporary zip archive. For  exam- ple:        zip -b /tmp stuff * will  put the temporary zip archive in the directory /tmp, copy- ing over stuff.zip to the current directory when done. This  op- tion  is  useful  when updating an existing archive and the file system containing this old archive does not have enough space to hold both old and new archives at the same time.  It may also be useful when streaming in some cases to avoid the need  for  data descriptors.   Note  that using this option may require zip take additional time to copy the archive file when done to the desti- nation file system."
      },
      {
        "key": "c",
        "title": "-c, --entry-comments",
        "description": "Add  one-line  comments for each file.  File operations (adding, updating) are done first, and the user is then  prompted  for  a one-line  comment  for each file.  Enter the comment followed by return, or just return for no comment."
      },
      {
        "key": "entry-comments",
        "title": "-c, --entry-comments",
        "description": "Add  one-line  comments for each file.  File operations (adding, updating) are done first, and the user is then  prompted  for  a one-line  comment  for each file.  Enter the comment followed by return, or just return for no comment."
      },
      {
        "key": "C",
        "title": "-C, --preserve-case",
        "description": "[VMS]  Preserve case all on VMS.   Negating  this  option  (-C-) downcases."
      },
      {
        "key": "preserve-case",
        "title": "-C, --preserve-case",
        "description": "[VMS]  Preserve case all on VMS.   Negating  this  option  (-C-) downcases."
      },
      {
        "key": "preserve-case-2",
        "title": "-C2, --preserve-case-2",
        "description": "[VMS]   Preserve  case ODS2 on VMS.  Negating this option (-C2-) downcases."
      },
      {
        "key": "preserve-case-5",
        "title": "-C5, --preserve-case-5",
        "description": "[VMS]  Preserve case ODS5 on VMS.  Negating this  option  (-C5-) downcases."
      },
      {
        "key": "d",
        "title": "-d, --delete",
        "description": "Remove (delete) entries from a zip archive.  For example:        zip -d foo foo/tom/junk foo/harry/\\* \\*.o will  remove the entry foo/tom/junk, all of the files that start with foo/harry/, and all of the files that end with .o  (in  any path).   Note  that  shell pathname expansion has been inhibited with backslashes, so that zip can see  the  asterisks,  enabling zip  to  match on the contents of the zip archive instead of the contents of the current directory.   (The  backslashes  are  not used  on  MSDOS-based platforms.)  Can also use quotes to escape the asterisks as in        zip -d foo foo/tom/junk \"foo/harry/*\" \"*.o\" Not escaping the asterisks on a system where the  shell  expands wildcards  could  result  in  the asterisks being converted to a list of files in the current directory and  that  list  used  to delete entries from the archive. Under  MSDOS,  -d is case sensitive when it matches names in the zip archive.  This requires that file names be entered in  upper case  if they were zipped by PKZIP on an MSDOS system.  (We con- sidered making this case insensitive on systems where paths were case  insensitive,  but  it  is possible the archive came from a system where case does matter and the archive could include both Bar  and bar as separate files in the archive.)  But see the new option -ic to ignore case in the archive."
      },
      {
        "key": "delete",
        "title": "-d, --delete",
        "description": "Remove (delete) entries from a zip archive.  For example:        zip -d foo foo/tom/junk foo/harry/\\* \\*.o will  remove the entry foo/tom/junk, all of the files that start with foo/harry/, and all of the files that end with .o  (in  any path).   Note  that  shell pathname expansion has been inhibited with backslashes, so that zip can see  the  asterisks,  enabling zip  to  match on the contents of the zip archive instead of the contents of the current directory.   (The  backslashes  are  not used  on  MSDOS-based platforms.)  Can also use quotes to escape the asterisks as in        zip -d foo foo/tom/junk \"foo/harry/*\" \"*.o\" Not escaping the asterisks on a system where the  shell  expands wildcards  could  result  in  the asterisks being converted to a list of files in the current directory and  that  list  used  to delete entries from the archive. Under  MSDOS,  -d is case sensitive when it matches names in the zip archive.  This requires that file names be entered in  upper case  if they were zipped by PKZIP on an MSDOS system.  (We con- sidered making this case insensitive on systems where paths were case  insensitive,  but  it  is possible the archive came from a system where case does matter and the archive could include both Bar  and bar as separate files in the archive.)  But see the new option -ic to ignore case in the archive."
      },
      {
        "key": "display-bytes",
        "title": "-db, --display-bytes",
        "description": "Display running byte counts showing the  bytes  zipped  and  the bytes to go."
      },
      {
        "key": "display-counts",
        "title": "-dc, --display-counts",
        "description": "Display running count of entries zipped and entries to go."
      },
      {
        "key": "display-dots",
        "title": "-dd, --display-dots",
        "description": "Display  dots  while  each entry is zipped (except on ports that have their own progress indicator).  See -ds below  for  setting dot  size.   The default is a dot every 10 MB of input file pro- cessed.  The -v option also displays dots (previously at a  much higher  rate  than  this  but now -v also defaults to 10 MB) and this rate is also controlled by -ds."
      },
      {
        "key": "datafork",
        "title": "-df, --datafork",
        "description": "[MacOS] Include only data-fork of files zipped into the archive. Good  for  exporting  files  to  foreign operating-systems.  Re- source-forks will be ignored at all."
      },
      {
        "key": "display-globaldots",
        "title": "-dg, --display-globaldots",
        "description": "Display progress dots for the archive instead of for each  file. The command            zip -qdgds 10m will turn off most output except dots every 10 MB."
      },
      {
        "key": "dot-size",
        "title": "-ds size, --dot-size size",
        "description": "Set  amount of input file processed for each dot displayed.  See -dd to enable displaying dots.  Setting this option implies -dd. Size  is  in the format nm where n is a number and m is a multi- plier.  Currently m can be k (KB), m (MB), g (GB), or t (TB), so if n is 100 and m is k, size would be 100k which is 100 KB.  The default is 10 MB. The -v option also displays dots and now defaults to 10 MB also. This  rate is also controlled by this option.  A size of 0 turns dots off. This option does not control the dots from the \"Scanning  files\" message  as zip scans for input files.  The dot size for that is fixed at 2 seconds or a fixed number of  entries,  whichever  is longer."
      },
      {
        "key": "display-usize",
        "title": "-du, --display-usize",
        "description": "Display the uncompressed size of each entry."
      },
      {
        "key": "display-volume",
        "title": "-dv, --display-volume",
        "description": "Display  the volume (disk) number each entry is being read from, if reading an existing archive, and being written to."
      },
      {
        "key": "D",
        "title": "-D, --no-dir-entries",
        "description": "Do not create entries in the zip archive for  directories.   Di- rectory  entries are created by default so that their attributes can be saved in  the  zip  archive.   The  environment  variable ZIPOPT  can  be  used to change the default options. For example under Unix with sh:        ZIPOPT=\"-D\"; export ZIPOPT (The variable ZIPOPT can be used for any  option,  including  -i and -x using a new option format detailed below, and can include several options.) The option -D is a shorthand for -x  \"*/\"  but the  latter previously could not be set as default in the ZIPOPT environment variable as the contents  of  ZIPOPT  gets  inserted near  the beginning of the command line and the file list had to end at the end of the line. This version of zip does allow -x and -i options  in  ZIPOPT  if the form  -x file file ... @ is used, where the @ (an argument that is just @) terminates the list."
      },
      {
        "key": "no-dir-entries",
        "title": "-D, --no-dir-entries",
        "description": "Do not create entries in the zip archive for  directories.   Di- rectory  entries are created by default so that their attributes can be saved in  the  zip  archive.   The  environment  variable ZIPOPT  can  be  used to change the default options. For example under Unix with sh:        ZIPOPT=\"-D\"; export ZIPOPT (The variable ZIPOPT can be used for any  option,  including  -i and -x using a new option format detailed below, and can include several options.) The option -D is a shorthand for -x  \"*/\"  but the  latter previously could not be set as default in the ZIPOPT environment variable as the contents  of  ZIPOPT  gets  inserted near  the beginning of the command line and the file list had to end at the end of the line. This version of zip does allow -x and -i options  in  ZIPOPT  if the form  -x file file ... @ is used, where the @ (an argument that is just @) terminates the list."
      },
      {
        "key": "difference-archive",
        "title": "-DF, --difference-archive",
        "description": "Create an archive that contains all new and changed files  since the  original  archive was created.  For this to work, the input file list and current directory must be the same as  during  the original zip operation. For example, if the existing archive was created using        zip -r foofull . from the bar directory, then the command        zip -r foofull . -DF --out foonew also from the bar directory creates the archive foonew with just the files not in foofull and the files where the  size  or  file time of the files do not match those in foofull. Note that the timezone environment variable TZ should be set ac- cording to the local timezone in order for this option  to  work correctly.   A change in timezone since the original archive was created could result in no times matching and  all  files  being included. A possible approach to backing up a directory might be to create a normal archive of the contents of  the  directory  as  a  full backup, then use this option to create incremental backups."
      },
      {
        "key": "e",
        "title": "-e, --encrypt",
        "description": "Encrypt  the  contents of the zip archive using a password which is entered on the terminal in response to a  prompt  (this  will not  be  echoed;  if  standard error is not a tty, zip will exit with an error).  The password prompt is  repeated  to  save  the user from typing errors."
      },
      {
        "key": "encrypt",
        "title": "-e, --encrypt",
        "description": "Encrypt  the  contents of the zip archive using a password which is entered on the terminal in response to a  prompt  (this  will not  be  echoed;  if  standard error is not a tty, zip will exit with an error).  The password prompt is  repeated  to  save  the user from typing errors."
      },
      {
        "key": "E",
        "title": "-E, --longnames",
        "description": "[OS/2]  Use the .LONGNAME Extended Attribute (if found) as file- name."
      },
      {
        "key": "longnames",
        "title": "-E, --longnames",
        "description": "[OS/2]  Use the .LONGNAME Extended Attribute (if found) as file- name."
      },
      {
        "key": "f",
        "title": "-f, --freshen",
        "description": "Replace (freshen) an existing entry in the zip archive  only  if it  has  been modified more recently than the version already in the zip archive; unlike the update option (-u) this will not add files that are not already in the zip archive.  For example:        zip -f foo This  command  should  be run from the same directory from which the original zip command was run, since paths stored in zip  ar- chives are always relative. Note that the timezone environment variable TZ should be set ac- cording to the local timezone in order for the -f, -u and -o op- tions to work correctly. The  reasons behind this are somewhat subtle but have to do with the differences between the Unix-format file  times  (always  in GMT) and most of the other operating systems (always local time) and the necessity to compare the two.  A  typical  TZ  value  is ``MET-1MEST''  (Middle  European  time with automatic adjustment for ``summertime'' or Daylight Savings Time). The format is TTThhDDD, where TTT is the time zone such as  MET, hh  is  the  difference  between  GMT  and local time such as -1 above, and DDD is the time zone when daylight savings time is in effect.  Leave off the DDD if there is no daylight savings time. For the US Eastern time zone EST5EDT."
      },
      {
        "key": "freshen",
        "title": "-f, --freshen",
        "description": "Replace (freshen) an existing entry in the zip archive  only  if it  has  been modified more recently than the version already in the zip archive; unlike the update option (-u) this will not add files that are not already in the zip archive.  For example:        zip -f foo This  command  should  be run from the same directory from which the original zip command was run, since paths stored in zip  ar- chives are always relative. Note that the timezone environment variable TZ should be set ac- cording to the local timezone in order for the -f, -u and -o op- tions to work correctly. The  reasons behind this are somewhat subtle but have to do with the differences between the Unix-format file  times  (always  in GMT) and most of the other operating systems (always local time) and the necessity to compare the two.  A  typical  TZ  value  is ``MET-1MEST''  (Middle  European  time with automatic adjustment for ``summertime'' or Daylight Savings Time). The format is TTThhDDD, where TTT is the time zone such as  MET, hh  is  the  difference  between  GMT  and local time such as -1 above, and DDD is the time zone when daylight savings time is in effect.  Leave off the DDD if there is no daylight savings time. For the US Eastern time zone EST5EDT."
      },
      {
        "key": "F",
        "title": "-F, --fix, -FF, --fixfix",
        "description": "Fix the zip archive. The -F option can be used if some  portions of  the  archive  are  missing, but requires a reasonably intact central directory.  The input archive is scanned as  usual,  but zip  will ignore some problems.  The resulting archive should be valid, but any inconsistent entries will be left out. When doubled as in -FF, the archive is scanned from  the  begin- ning and zip scans for special signatures to identify the limits between the archive members. The single -F is more  reliable  if the archive is not too much damaged, so try this option first. If the archive is too damaged or the end has been truncated, you must use -FF.  This is a change from zip 2.32, where the -F  op- tion  is  able  to  read a truncated archive.  The -F option now more reliably fixes archives with minor damage and the  -FF  op- tion  is  needed to fix archives where -F might have been suffi- cient before. Neither option will recover archives that have been  incorrectly transferred  in  ascii mode instead of binary. After the repair, the -t option of unzip may show that some files have a bad  CRC. Such files cannot be recovered; you can remove them from the ar- chive using the -d option of zip. Note that -FF may have trouble fixing archives that  include  an embedded  zip  archive  that was stored (without compression) in the archive and, depending on the damage, it may  find  the  en- tries  in  the  embedded archive rather than the archive itself. Try -F first as it does not have this problem. The format of the fix commands have changed.   For  example,  to fix the damaged archive foo.zip,        zip -F foo --out foofix tries  to read the entries normally, copying good entries to the new archive foofix.zip.  If this doesn't work, as when  the  ar- chive  is  truncated, or if some entries you know are in the ar- chive are missed, then try        zip -FF foo --out foofixfix and compare the resulting archive to the archive created by  -F. The -FF option may create an inconsistent archive.  Depending on what is damaged, you can then use the -F option to fix that  ar- chive. A  split  archive with missing split files can be fixed using -F if you have the last split of the archive (the .zip  file).   If this file is missing, you must use -FF to fix the archive, which will prompt you for the splits you have. Currently the fix options can't recover entries that have a  bad checksum or are otherwise damaged."
      },
      {
        "key": "fix",
        "title": "-F, --fix, -FF, --fixfix",
        "description": "Fix the zip archive. The -F option can be used if some  portions of  the  archive  are  missing, but requires a reasonably intact central directory.  The input archive is scanned as  usual,  but zip  will ignore some problems.  The resulting archive should be valid, but any inconsistent entries will be left out. When doubled as in -FF, the archive is scanned from  the  begin- ning and zip scans for special signatures to identify the limits between the archive members. The single -F is more  reliable  if the archive is not too much damaged, so try this option first. If the archive is too damaged or the end has been truncated, you must use -FF.  This is a change from zip 2.32, where the -F  op- tion  is  able  to  read a truncated archive.  The -F option now more reliably fixes archives with minor damage and the  -FF  op- tion  is  needed to fix archives where -F might have been suffi- cient before. Neither option will recover archives that have been  incorrectly transferred  in  ascii mode instead of binary. After the repair, the -t option of unzip may show that some files have a bad  CRC. Such files cannot be recovered; you can remove them from the ar- chive using the -d option of zip. Note that -FF may have trouble fixing archives that  include  an embedded  zip  archive  that was stored (without compression) in the archive and, depending on the damage, it may  find  the  en- tries  in  the  embedded archive rather than the archive itself. Try -F first as it does not have this problem. The format of the fix commands have changed.   For  example,  to fix the damaged archive foo.zip,        zip -F foo --out foofix tries  to read the entries normally, copying good entries to the new archive foofix.zip.  If this doesn't work, as when  the  ar- chive  is  truncated, or if some entries you know are in the ar- chive are missed, then try        zip -FF foo --out foofixfix and compare the resulting archive to the archive created by  -F. The -FF option may create an inconsistent archive.  Depending on what is damaged, you can then use the -F option to fix that  ar- chive. A  split  archive with missing split files can be fixed using -F if you have the last split of the archive (the .zip  file).   If this file is missing, you must use -FF to fix the archive, which will prompt you for the splits you have. Currently the fix options can't recover entries that have a  bad checksum or are otherwise damaged."
      },
      {
        "key": "fixfix",
        "title": "-F, --fix, -FF, --fixfix",
        "description": "Fix the zip archive. The -F option can be used if some  portions of  the  archive  are  missing, but requires a reasonably intact central directory.  The input archive is scanned as  usual,  but zip  will ignore some problems.  The resulting archive should be valid, but any inconsistent entries will be left out. When doubled as in -FF, the archive is scanned from  the  begin- ning and zip scans for special signatures to identify the limits between the archive members. The single -F is more  reliable  if the archive is not too much damaged, so try this option first. If the archive is too damaged or the end has been truncated, you must use -FF.  This is a change from zip 2.32, where the -F  op- tion  is  able  to  read a truncated archive.  The -F option now more reliably fixes archives with minor damage and the  -FF  op- tion  is  needed to fix archives where -F might have been suffi- cient before. Neither option will recover archives that have been  incorrectly transferred  in  ascii mode instead of binary. After the repair, the -t option of unzip may show that some files have a bad  CRC. Such files cannot be recovered; you can remove them from the ar- chive using the -d option of zip. Note that -FF may have trouble fixing archives that  include  an embedded  zip  archive  that was stored (without compression) in the archive and, depending on the damage, it may  find  the  en- tries  in  the  embedded archive rather than the archive itself. Try -F first as it does not have this problem. The format of the fix commands have changed.   For  example,  to fix the damaged archive foo.zip,        zip -F foo --out foofix tries  to read the entries normally, copying good entries to the new archive foofix.zip.  If this doesn't work, as when  the  ar- chive  is  truncated, or if some entries you know are in the ar- chive are missed, then try        zip -FF foo --out foofixfix and compare the resulting archive to the archive created by  -F. The -FF option may create an inconsistent archive.  Depending on what is damaged, you can then use the -F option to fix that  ar- chive. A  split  archive with missing split files can be fixed using -F if you have the last split of the archive (the .zip  file).   If this file is missing, you must use -FF to fix the archive, which will prompt you for the splits you have. Currently the fix options can't recover entries that have a  bad checksum or are otherwise damaged."
      },
      {
        "key": "fifo",
        "title": "--fifo [Unix]",
        "description": "Normally  zip skips reading any FIFOs (named pipes) en-"
      },
      {
        "key": "filesync",
        "title": "-FS, --filesync",
        "description": "Synchronize the contents of an archive with the files on the OS. Normally when an archive is updated, new  files  are  added  and changed  files are updated but files that no longer exist on the OS are not deleted from the archive.  This option enables a  new mode that checks entries in the archive against the file system. If the file time and file size of the entry matches that of  the OS file, the entry is copied from the old archive instead of be- ing read from the file system and compressed.  If  the  OS  file has  changed, the entry is read and compressed as usual.  If the entry in the archive does not match a file on the OS, the  entry is  deleted.   Enabling  this option should create archives that are the same as new archives, but  since  existing  entries  are copied  instead of compressed, updating an existing archive with -FS can be much faster than creating a new archive.   Also  con- sider using -u for updating an archive. For  this option to work, the archive should be updated from the same directory it was created in so the  relative  paths  match. If  few  files  are being copied from the old archive, it may be faster to create a new archive instead. Note that the timezone environment variable TZ should be set ac- cording  to  the local timezone in order for this option to work correctly.  A change in timezone since the original archive  was created  could  result in no times matching and recompression of all files. This option deletes files from the archive.  If you need to pre- serve  the original archive, make a copy of the archive first or use the --out option to output the  updated  archive  to  a  new file.  Even though it may be slower, creating a new archive with a new archive name is safer, avoids mismatches  between  archive and OS paths, and is preferred."
      },
      {
        "key": "g",
        "title": "-g, --grow",
        "description": "Grow  (append to) the specified zip archive, instead of creating a new one. If this operation fails, zip attempts to restore  the archive to its original state. If the restoration fails, the ar- chive might  become  corrupted.  This  option  is  ignored  when there's  no existing archive or when at least one archive member must be updated or deleted."
      },
      {
        "key": "grow",
        "title": "-g, --grow",
        "description": "Grow  (append to) the specified zip archive, instead of creating a new one. If this operation fails, zip attempts to restore  the archive to its original state. If the restoration fails, the ar- chive might  become  corrupted.  This  option  is  ignored  when there's  no existing archive or when at least one archive member must be updated or deleted."
      },
      {
        "key": "h",
        "title": "-h, -?, --help",
        "description": "Display the zip help information (this also appears  if  zip  is run with no arguments)."
      },
      {
        "key": "?",
        "title": "-h, -?, --help",
        "description": "Display the zip help information (this also appears  if  zip  is run with no arguments)."
      },
      {
        "key": "help",
        "title": "-h, -?, --help",
        "description": "Display the zip help information (this also appears  if  zip  is run with no arguments)."
      },
      {
        "key": "more-help",
        "title": "-h2, --more-help",
        "description": "Display  extended  help  including  more on command line format, pattern matching, and more obscure options."
      },
      {
        "key": "i",
        "title": "-i files, --include files",
        "description": "Include only the specified files, as in:        zip -r foo . -i \\*.c which will include only the files that end in .c in the  current directory  and  its  subdirectories.  (Note for PKZIP users: the equivalent command is        pkzip -rP foo *.c PKZIP does not allow recursion in  directories  other  than  the current one.)  The backslash avoids the shell filename substitu- tion, so that the name matching is performed by zip at  all  di- rectory  levels.   [This  is  for Unix and other systems where \\ escapes the next character.  For other systems where  the  shell does not process * do not use \\ and the above is        zip -r foo . -i *.c Examples  are  for  Unix unless otherwise specified.]  So to in- clude dir, a directory directly under the current directory, use        zip -r foo . -i dir/\\* or        zip -r foo . -i \"dir/*\" to match paths such as dir/a and dir/b/file.c [on ports  without wildcard expansion in the shell such as MSDOS and Windows        zip -r foo . -i dir/* is  used.]  Note that currently the trailing / is needed for di- rectories (as in        zip -r foo . -i dir/ to include directory dir). The long option form of the first example is        zip -r foo . --include \\*.c and does the same thing as the short option form. Though the command syntax used to require -i at the end  of  the command  line,  this  version  actually allows -i (or --include) anywhere.  The list of files terminates  at  the  next  argument starting with -, the end of the command line, or the list termi- nator @ (an argument that is just @).  So the above can be given as        zip -i \\*.c @ -r foo . for  example.   There must be a space between the option and the first file of a list.  For just one file you can use the  single value form        zip -i\\*.c -r foo . (no space between option and value) or        zip --include=\\*.c -r foo . as  additional  examples.  The single value forms are not recom- mended because they can be confusing  and,  in  particular,  the -ifile  format  can  cause  problems if the first letter of file combines with i to form a two-letter  option  starting  with  i. Use -sc to see how your command line will be parsed. Also possible:        zip -r foo  . -i@include.lst which  will  only include the files in the current directory and its subdirectories that match  the  patterns  in  the  file  in- clude.lst. Files to -i and -x are patterns matching internal archive paths. See -R for more on patterns."
      },
      {
        "key": "include",
        "title": "-i files, --include files",
        "description": "Include only the specified files, as in:        zip -r foo . -i \\*.c which will include only the files that end in .c in the  current directory  and  its  subdirectories.  (Note for PKZIP users: the equivalent command is        pkzip -rP foo *.c PKZIP does not allow recursion in  directories  other  than  the current one.)  The backslash avoids the shell filename substitu- tion, so that the name matching is performed by zip at  all  di- rectory  levels.   [This  is  for Unix and other systems where \\ escapes the next character.  For other systems where  the  shell does not process * do not use \\ and the above is        zip -r foo . -i *.c Examples  are  for  Unix unless otherwise specified.]  So to in- clude dir, a directory directly under the current directory, use        zip -r foo . -i dir/\\* or        zip -r foo . -i \"dir/*\" to match paths such as dir/a and dir/b/file.c [on ports  without wildcard expansion in the shell such as MSDOS and Windows        zip -r foo . -i dir/* is  used.]  Note that currently the trailing / is needed for di- rectories (as in        zip -r foo . -i dir/ to include directory dir). The long option form of the first example is        zip -r foo . --include \\*.c and does the same thing as the short option form. Though the command syntax used to require -i at the end  of  the command  line,  this  version  actually allows -i (or --include) anywhere.  The list of files terminates  at  the  next  argument starting with -, the end of the command line, or the list termi- nator @ (an argument that is just @).  So the above can be given as        zip -i \\*.c @ -r foo . for  example.   There must be a space between the option and the first file of a list.  For just one file you can use the  single value form        zip -i\\*.c -r foo . (no space between option and value) or        zip --include=\\*.c -r foo . as  additional  examples.  The single value forms are not recom- mended because they can be confusing  and,  in  particular,  the -ifile  format  can  cause  problems if the first letter of file combines with i to form a two-letter  option  starting  with  i. Use -sc to see how your command line will be parsed. Also possible:        zip -r foo  . -i@include.lst which  will  only include the files in the current directory and its subdirectories that match  the  patterns  in  the  file  in- clude.lst. Files to -i and -x are patterns matching internal archive paths. See -R for more on patterns."
      },
      {
        "key": "I",
        "title": "-I, --no-image",
        "description": "[Acorn RISC OS] Don't scan through Image files.  When used,  zip will  not  consider Image files (eg. DOS partitions or Spark ar- chives when SparkFS is loaded) as  directories  but  will  store them as single files. For example, if you have SparkFS loaded, zipping a Spark archive will result in a zipfile containing a directory  (and  its  con- tent)  while  using the 'I' option will result in a zipfile con- taining a Spark archive. Obviously this second case will also be obtained (without the 'I' option) if SparkFS isn't loaded."
      },
      {
        "key": "no-image",
        "title": "-I, --no-image",
        "description": "[Acorn RISC OS] Don't scan through Image files.  When used,  zip will  not  consider Image files (eg. DOS partitions or Spark ar- chives when SparkFS is loaded) as  directories  but  will  store them as single files. For example, if you have SparkFS loaded, zipping a Spark archive will result in a zipfile containing a directory  (and  its  con- tent)  while  using the 'I' option will result in a zipfile con- taining a Spark archive. Obviously this second case will also be obtained (without the 'I' option) if SparkFS isn't loaded."
      },
      {
        "key": "ignore-case",
        "title": "-ic, --ignore-case",
        "description": "[VMS,  WIN32]  Ignore  case when matching archive entries.  This option is only available on systems where the case of  files  is ignored.  On systems with case-insensitive file systems, case is normally ignored when matching files on the file system  but  is not  ignored for -f (freshen), -d (delete), -U (copy), and simi- lar modes when matching against archive  entries  (currently  -f ignores case on VMS) because archive entries can be from systems where case does matter and names that are the  same  except  for case can exist in an archive.  The -ic option makes all matching case insensitive.  This can result in multiple  archive  entries matching a command line pattern."
      },
      {
        "key": "j",
        "title": "-j, --junk-paths",
        "description": "Store  just the name of a saved file (junk the path), and do not store directory names. By default, zip will store the full  path (relative to the current directory)."
      },
      {
        "key": "junk-paths",
        "title": "-j, --junk-paths",
        "description": "Store  just the name of a saved file (junk the path), and do not store directory names. By default, zip will store the full  path (relative to the current directory)."
      },
      {
        "key": "absolute-path",
        "title": "-jj, --absolute-path",
        "description": "[MacOS] record Fullpath (+ Volname). The complete path including volume will be stored. By default  the  relative  path  will  be stored."
      },
      {
        "key": "J",
        "title": "-J, --junk-sfx",
        "description": "Strip any prepended data (e.g. a SFX stub) from the archive."
      },
      {
        "key": "junk-sfx",
        "title": "-J, --junk-sfx",
        "description": "Strip any prepended data (e.g. a SFX stub) from the archive."
      },
      {
        "key": "k",
        "title": "-k, --DOS-names",
        "description": "Attempt  to  convert  the  names  and paths to conform to MSDOS, store only the MSDOS attribute (just the  user  write  attribute from  Unix), and mark the entry as made under MSDOS (even though it was not); for compatibility with PKUNZIP  under  MSDOS  which cannot handle certain names such as those with two dots."
      },
      {
        "key": "DOS-names",
        "title": "-k, --DOS-names",
        "description": "Attempt  to  convert  the  names  and paths to conform to MSDOS, store only the MSDOS attribute (just the  user  write  attribute from  Unix), and mark the entry as made under MSDOS (even though it was not); for compatibility with PKUNZIP  under  MSDOS  which cannot handle certain names such as those with two dots."
      },
      {
        "key": "l",
        "title": "-l, --to-crlf",
        "description": "Translate  the Unix end-of-line character LF into the MSDOS con- vention CR LF. This option should not be used on  binary  files. This  option can be used on Unix if the zip file is intended for PKUNZIP under MSDOS. If the input files already contain  CR  LF, this option adds an extra CR. This is to ensure that unzip -a on Unix will get back an exact copy of the original file,  to  undo the effect of zip -l.  See -ll for how binary files are handled."
      },
      {
        "key": "to-crlf",
        "title": "-l, --to-crlf",
        "description": "Translate  the Unix end-of-line character LF into the MSDOS con- vention CR LF. This option should not be used on  binary  files. This  option can be used on Unix if the zip file is intended for PKUNZIP under MSDOS. If the input files already contain  CR  LF, this option adds an extra CR. This is to ensure that unzip -a on Unix will get back an exact copy of the original file,  to  undo the effect of zip -l.  See -ll for how binary files are handled."
      },
      {
        "key": "log-append",
        "title": "-la, --log-append",
        "description": "Append to existing logfile.  Default is to overwrite."
      },
      {
        "key": "logfile-path",
        "title": "-lf logfilepath, --logfile-path logfilepath",
        "description": "Open  a logfile at the given path.  By default any existing file at that location is overwritten, but the -la option will  result in an existing file being opened and the new log information ap- pended to any existing information.  Only  warnings  and  errors are written to the log unless the -li option is also given, then all information messages are also written to the log."
      },
      {
        "key": "log-info",
        "title": "-li, --log-info",
        "description": "Include information messages, such as file names  being  zipped, in  the  log.   The default is to only include the command line, any warnings and errors, and the final status."
      },
      {
        "key": "from-crlf",
        "title": "-ll, --from-crlf",
        "description": "Translate the MSDOS end-of-line CR LF into Unix LF.  This option should  not be used on binary files.  This option can be used on MSDOS if the zip file is intended for unzip under Unix.  If  the file  is converted and the file is later determined to be binary a warning is issued and the file is probably corrupted.  In this release  if  -ll  detects binary in the first buffer read from a file, zip now issues a warning and skips line end conversion  on the  file.   This  check seems to catch all binary files tested, but the original check remains and if a converted file is  later determined to be binary that warning is still issued.  A new al- gorithm is now being used for binary detection that should allow line  end  conversion  of text files in UTF-8 and similar encod- ings."
      },
      {
        "key": "L",
        "title": "-L, --license",
        "description": "Display the zip license."
      },
      {
        "key": "license",
        "title": "-L, --license",
        "description": "Display the zip license."
      },
      {
        "key": "m",
        "title": "-m, --move",
        "description": "Move the specified files into the zip  archive;  actually,  this deletes  the target directories/files after making the specified zip archive. If a directory becomes empty after removal  of  the files,  the directory is also removed. No deletions are done un- til zip has created the archive without error.  This  is  useful for conserving disk space, but is potentially dangerous so it is recommended to use it in combination with -T to test the archive before removing all input files."
      },
      {
        "key": "move",
        "title": "-m, --move",
        "description": "Move the specified files into the zip  archive;  actually,  this deletes  the target directories/files after making the specified zip archive. If a directory becomes empty after removal  of  the files,  the directory is also removed. No deletions are done un- til zip has created the archive without error.  This  is  useful for conserving disk space, but is potentially dangerous so it is recommended to use it in combination with -T to test the archive before removing all input files."
      },
      {
        "key": "must-match",
        "title": "-MM, --must-match",
        "description": "All  input  patterns  must match at least one file and all input files found must be readable.  Normally when  an  input  pattern does  not  match a file the \"name not matched\" warning is issued and when an input file has been found but later  is  missing  or not  readable  a  missing or not readable warning is issued.  In either case zip continues creating the archive, with missing  or unreadable  new files being skipped and files already in the ar- chive remaining unchanged.  After the archive is created, if any files  were  not readable zip returns the OPEN error code (18 on most systems) instead of the normal success return  (0  on  most systems).   With  -MM set, zip exits as soon as an input pattern is not matched (whenever the \"name not matched\" warning would be issued)  or  when an input file is not readable.  In either case zip exits with an OPEN error and no archive is created. This option is useful when a known list of files is to be zipped so  any missing or unreadable files will result in an error.  It is less useful when used with wildcards, but zip will still exit with  an  error  if any input pattern doesn't match at least one file and if any matched files are unreadable.  If  you  want  to create  the  archive  anyway and only need to know if files were skipped, don't use -MM and just check the return code.  Also -lf could be useful."
      },
      {
        "key": "n",
        "title": "-n suffixes, --suffixes suffixes",
        "description": "Do  not attempt to compress files named with the given suffixes. Such files are simply stored (0% compression) in the output  zip file,  so  that  zip  doesn't  waste its time trying to compress them.  The suffixes are separated  by  either  colons  or  semi- colons.  For example:        zip -rn .Z:.zip:.tiff:.gif:.snd  foo foo will  copy  everything from foo into foo.zip, but will store any files that end in .Z, .zip, .tiff, .gif, or .snd without  trying to  compress  them  (image  and sound files often have their own specialized compression methods).  By default, zip does not com- press      files     with     extensions     in     the     list .Z:.zip:.zoo:.arc:.lzh:.arj.  Such files are stored directly  in the output archive.  The environment variable ZIPOPT can be used to change the default options. For example under Unix with csh:        setenv ZIPOPT \"-n .gif:.zip\" To attempt compression on all files, use:        zip -n : foo The maximum compression option -9 also attempts  compression  on all files regardless of extension. On  Acorn RISC OS systems the suffixes are actually filetypes (3 hex digit format). By default, zip does not compress files  with filetypes  in the list DDC:D96:68E (i.e. Archives, CFS files and PackDir files)."
      },
      {
        "key": "suffixes",
        "title": "-n suffixes, --suffixes suffixes",
        "description": "Do  not attempt to compress files named with the given suffixes. Such files are simply stored (0% compression) in the output  zip file,  so  that  zip  doesn't  waste its time trying to compress them.  The suffixes are separated  by  either  colons  or  semi- colons.  For example:        zip -rn .Z:.zip:.tiff:.gif:.snd  foo foo will  copy  everything from foo into foo.zip, but will store any files that end in .Z, .zip, .tiff, .gif, or .snd without  trying to  compress  them  (image  and sound files often have their own specialized compression methods).  By default, zip does not com- press      files     with     extensions     in     the     list .Z:.zip:.zoo:.arc:.lzh:.arj.  Such files are stored directly  in the output archive.  The environment variable ZIPOPT can be used to change the default options. For example under Unix with csh:        setenv ZIPOPT \"-n .gif:.zip\" To attempt compression on all files, use:        zip -n : foo The maximum compression option -9 also attempts  compression  on all files regardless of extension. On  Acorn RISC OS systems the suffixes are actually filetypes (3 hex digit format). By default, zip does not compress files  with filetypes  in the list DDC:D96:68E (i.e. Archives, CFS files and PackDir files)."
      },
      {
        "key": "no-wild",
        "title": "-nw, --no-wild",
        "description": "Do not perform internal wildcard processing (shell processing of wildcards  is  still  done by the shell unless the arguments are escaped).  Useful if a list of paths is being read and no  wild- card substitution is desired."
      },
      {
        "key": "N",
        "title": "-N, --notes",
        "description": "[Amiga,  MacOS]  Save  Amiga  or MacOS filenotes as zipfile com- ments. They can be restored by using the -N option of unzip.  If -c  is  used  also, you are prompted for comments only for those files that do not have filenotes."
      },
      {
        "key": "notes",
        "title": "-N, --notes",
        "description": "[Amiga,  MacOS]  Save  Amiga  or MacOS filenotes as zipfile com- ments. They can be restored by using the -N option of unzip.  If -c  is  used  also, you are prompted for comments only for those files that do not have filenotes."
      },
      {
        "key": "o",
        "title": "-o, --latest-time",
        "description": "Set the \"last modified\" time of the zip archive  to  the  latest (oldest) \"last modified\" time found among the entries in the zip archive.  This can be used without any other operations, if  de- sired.  For example: zip -o foo will change the last modified time of foo.zip to the latest time of the entries in foo.zip."
      },
      {
        "key": "latest-time",
        "title": "-o, --latest-time",
        "description": "Set the \"last modified\" time of the zip archive  to  the  latest (oldest) \"last modified\" time found among the entries in the zip archive.  This can be used without any other operations, if  de- sired.  For example: zip -o foo will change the last modified time of foo.zip to the latest time of the entries in foo.zip."
      },
      {
        "key": "O",
        "title": "-O output-file, --output-file output-file",
        "description": "Process the archive changes as usual, but  instead  of  updating the  existing  archive,  output  the new archive to output-file. Useful for updating an archive without changing the existing ar- chive  and  the  input archive must be a different file than the output archive. This option can be used to create updated  split  archives.   It can  also  be  used with -U to copy entries from an existing ar- chive to a new archive.  See the EXAMPLES section below. Another use is converting zip files from one split size  to  an- other.   For  instance,  to  convert  an  archive with 700 MB CD splits to one with 2 GB DVD splits, can use:        zip -s 2g cd-split.zip --out dvd-split.zip which uses copy mode.  See -U below.  Also:        zip -s 0 split.zip --out unsplit.zip will convert a split archive to a single-file archive. Copy mode will convert stream entries  (using  data  descriptors and  which  should be compatible with most unzips) to normal en- tries (which should be compatible with all  unzips),  except  if standard  encryption  was used.  For archives with encrypted en- tries, zipcloak will decrypt the entries  and  convert  them  to normal entries."
      },
      {
        "key": "output-file",
        "title": "-O output-file, --output-file output-file",
        "description": "Process the archive changes as usual, but  instead  of  updating the  existing  archive,  output  the new archive to output-file. Useful for updating an archive without changing the existing ar- chive  and  the  input archive must be a different file than the output archive. This option can be used to create updated  split  archives.   It can  also  be  used with -U to copy entries from an existing ar- chive to a new archive.  See the EXAMPLES section below. Another use is converting zip files from one split size  to  an- other.   For  instance,  to  convert  an  archive with 700 MB CD splits to one with 2 GB DVD splits, can use:        zip -s 2g cd-split.zip --out dvd-split.zip which uses copy mode.  See -U below.  Also:        zip -s 0 split.zip --out unsplit.zip will convert a split archive to a single-file archive. Copy mode will convert stream entries  (using  data  descriptors and  which  should be compatible with most unzips) to normal en- tries (which should be compatible with all  unzips),  except  if standard  encryption  was used.  For archives with encrypted en- tries, zipcloak will decrypt the entries  and  convert  them  to normal entries."
      },
      {
        "key": "p",
        "title": "-p, --paths",
        "description": "Include relative file paths as part of the names of files stored in the archive.  This is the default.  The -j option  junks  the paths and just stores the names of the files."
      },
      {
        "key": "paths",
        "title": "-p, --paths",
        "description": "Include relative file paths as part of the names of files stored in the archive.  This is the default.  The -j option  junks  the paths and just stores the names of the files."
      },
      {
        "key": "P",
        "title": "-P password, --password password",
        "description": "Use password to encrypt zipfile entries (if any).  THIS IS INSE- CURE!  Many multi-user operating systems provide  ways  for  any user  to see the current command line of any other user; even on stand-alone systems there is  always  the  threat  of  over-the- shoulder  peeking.   Storing the plaintext password as part of a command line in an automated script  is  even  worse.   Whenever possible, use the non-echoing, interactive prompt to enter pass- words.  (And where security is truly important, use  strong  en- cryption  such  as Pretty Good Privacy instead of the relatively weak standard encryption provided by zipfile utilities.)"
      },
      {
        "key": "password",
        "title": "-P password, --password password",
        "description": "Use password to encrypt zipfile entries (if any).  THIS IS INSE- CURE!  Many multi-user operating systems provide  ways  for  any user  to see the current command line of any other user; even on stand-alone systems there is  always  the  threat  of  over-the- shoulder  peeking.   Storing the plaintext password as part of a command line in an automated script  is  even  worse.   Whenever possible, use the non-echoing, interactive prompt to enter pass- words.  (And where security is truly important, use  strong  en- cryption  such  as Pretty Good Privacy instead of the relatively weak standard encryption provided by zipfile utilities.)"
      },
      {
        "key": "q",
        "title": "-q, --quiet",
        "description": "Quiet  mode;  eliminate  informational  messages   and   comment prompts.   (Useful, for example, in shell scripts and background tasks)."
      },
      {
        "key": "quiet",
        "title": "-q, --quiet",
        "description": "Quiet  mode;  eliminate  informational  messages   and   comment prompts.   (Useful, for example, in shell scripts and background tasks)."
      },
      {
        "key": "Q-flag",
        "title": "-Qn, --Q-flag n",
        "description": "[QDOS] store information about the file in the file header  with n defined as bit  0: Don't add headers for any file bit  1: Add headers for all files bit  2: Don't wait for interactive key press on exit"
      },
      {
        "key": "r",
        "title": "-r, --recurse-paths",
        "description": "Travel the directory structure recursively; for example:        zip -r foo.zip foo or more concisely        zip -r foo foo In  this case, all the files and directories in foo are saved in a zip archive named foo.zip, including files with names starting with \".\", since the recursion does not use the shell's file-name substitution mechanism.  If you wish to include only a  specific subset of the files in directory foo and its subdirectories, use the -i option to specify the pattern of files  to  be  included. You  should  not  use  -r with the name \".*\", since that matches \"..\"  which will attempt to zip up the parent directory  (proba- bly not what was intended). Multiple source directories are allowed as in        zip -r foo foo1 foo2 which  first  zips up foo1 and then foo2, going down each direc- tory. Note that while wildcards to -r are typically resolved while re- cursing  down directories in the file system, any -R, -x, and -i wildcards are applied to internal archive pathnames once the di- rectories are scanned.  To have wildcards apply to files in sub- directories when recursing on Unix and similar systems where the shell does wildcard substitution, either escape all wildcards or put all arguments with wildcards in quotes.  This lets  zip  see the wildcards and match files in subdirectories using them as it recurses."
      },
      {
        "key": "recurse-paths",
        "title": "-r, --recurse-paths",
        "description": "Travel the directory structure recursively; for example:        zip -r foo.zip foo or more concisely        zip -r foo foo In  this case, all the files and directories in foo are saved in a zip archive named foo.zip, including files with names starting with \".\", since the recursion does not use the shell's file-name substitution mechanism.  If you wish to include only a  specific subset of the files in directory foo and its subdirectories, use the -i option to specify the pattern of files  to  be  included. You  should  not  use  -r with the name \".*\", since that matches \"..\"  which will attempt to zip up the parent directory  (proba- bly not what was intended). Multiple source directories are allowed as in        zip -r foo foo1 foo2 which  first  zips up foo1 and then foo2, going down each direc- tory. Note that while wildcards to -r are typically resolved while re- cursing  down directories in the file system, any -R, -x, and -i wildcards are applied to internal archive pathnames once the di- rectories are scanned.  To have wildcards apply to files in sub- directories when recursing on Unix and similar systems where the shell does wildcard substitution, either escape all wildcards or put all arguments with wildcards in quotes.  This lets  zip  see the wildcards and match files in subdirectories using them as it recurses."
      },
      {
        "key": "R",
        "title": "-R, --recurse-patterns",
        "description": "Travel the directory structure recursively starting at the  cur- rent directory; for example:        zip -R foo \"*.c\" In this case, all the files matching *.c in the tree starting at the current directory  are  stored  into  a  zip  archive  named foo.zip.   Note that *.c will match file.c, a/file.c and a/b/.c. More than one pattern can be listed as separate arguments.  Note for PKZIP users: the equivalent command is        pkzip -rP foo *.c Patterns  are relative file paths as they appear in the archive, or will after zipping, and can have optional wildcards in  them. For example, given the current directory is foo and under it are directories foo1 and foo2 and in foo1 is the file bar.c,        zip -R foo/* will zip up foo, foo/foo1, foo/foo1/bar.c, and foo/foo2.        zip -R */bar.c will zip up foo/foo1/bar.c.  See the note  for  -r  on  escaping wildcards."
      },
      {
        "key": "recurse-patterns",
        "title": "-R, --recurse-patterns",
        "description": "Travel the directory structure recursively starting at the  cur- rent directory; for example:        zip -R foo \"*.c\" In this case, all the files matching *.c in the tree starting at the current directory  are  stored  into  a  zip  archive  named foo.zip.   Note that *.c will match file.c, a/file.c and a/b/.c. More than one pattern can be listed as separate arguments.  Note for PKZIP users: the equivalent command is        pkzip -rP foo *.c Patterns  are relative file paths as they appear in the archive, or will after zipping, and can have optional wildcards in  them. For example, given the current directory is foo and under it are directories foo1 and foo2 and in foo1 is the file bar.c,        zip -R foo/* will zip up foo, foo/foo1, foo/foo1/bar.c, and foo/foo2.        zip -R */bar.c will zip up foo/foo1/bar.c.  See the note  for  -r  on  escaping wildcards."
      },
      {
        "key": "regex",
        "title": "-RE, --regex",
        "description": "[WIN32]   Before  zip  3.0, regular expression list matching was enabled by default on Windows platforms.  Because  of  confusion resulting  from  the  need to escape \"[\" and \"]\" in names, it is now off by default for Windows so \"[\" and \"]\"  are  just  normal characters in names.  This option enables [] matching again."
      },
      {
        "key": "s",
        "title": "-s splitsize, --split-size splitsize",
        "description": "Enable creating a split archive and set the split size.  A split archive is an archive that could be split over many  files.   As the  archive  is created, if the size of the archive reaches the specified split size, that split is closed and  the  next  split opened.   In  general  all splits but the last will be the split size and the last will be whatever is left.  If the  entire  ar- chive  is  smaller  than the split size a single-file archive is created. Split archives are stored in numbered files.   For  example,  if the  output  archive  is  named archive and three splits are re- quired, the resulting archive will be in  the  three  files  ar- chive.z01, archive.z02, and archive.zip.  Do not change the num- bering of these files or the archive will  not  be  readable  as these are used to determine the order the splits are read. Split  size  is  a  number  optionally followed by a multiplier. Currently the number must be an  integer.   The  multiplier  can currently be one of k (kilobytes), m (megabytes), g (gigabytes), or t (terabytes).  As 64k is the  minimum  split  size,  numbers without  multipliers default to megabytes.  For example, to cre- ate a split archive called foo with the contents of the bar  di- rectory  with  splits of 670 MB that might be useful for burning on CDs, the command:        zip -s 670m -r foo bar could be used. Currently the old splits of a split  archive  are  not  excluded from  a  new archive, but they can be specifically excluded.  If possible, keep the input and output archives out of the path be- ing zipped when creating split archives. Using  -s  without -sp as above creates all the splits where foo is being written, in this  case  the  current  directory.   This split  mode  updates the splits as the archive is being created, requiring all splits to remain writable, but creates  split  ar- chives  that  are  readable by any unzip that supports split ar- chives.  See -sp below for enabling split pause mode  which  al- lows splits to be written directly to removable media. The  option -sv can be used to enable verbose splitting and pro- vide details of how the splitting is being done.  The -sb option can  be used to ring the bell when zip pauses for the next split destination. Split archives cannot be updated, but see the -O (--out)  option for  how a split archive can be updated as it is copied to a new archive.  A split archive can also be converted into  a  single- file archive using a split size of 0 or negating the -s option:        zip -s 0 split.zip --out single.zip Also see -U (--copy) for more on using copy mode."
      },
      {
        "key": "split-size",
        "title": "-s splitsize, --split-size splitsize",
        "description": "Enable creating a split archive and set the split size.  A split archive is an archive that could be split over many  files.   As the  archive  is created, if the size of the archive reaches the specified split size, that split is closed and  the  next  split opened.   In  general  all splits but the last will be the split size and the last will be whatever is left.  If the  entire  ar- chive  is  smaller  than the split size a single-file archive is created. Split archives are stored in numbered files.   For  example,  if the  output  archive  is  named archive and three splits are re- quired, the resulting archive will be in  the  three  files  ar- chive.z01, archive.z02, and archive.zip.  Do not change the num- bering of these files or the archive will  not  be  readable  as these are used to determine the order the splits are read. Split  size  is  a  number  optionally followed by a multiplier. Currently the number must be an  integer.   The  multiplier  can currently be one of k (kilobytes), m (megabytes), g (gigabytes), or t (terabytes).  As 64k is the  minimum  split  size,  numbers without  multipliers default to megabytes.  For example, to cre- ate a split archive called foo with the contents of the bar  di- rectory  with  splits of 670 MB that might be useful for burning on CDs, the command:        zip -s 670m -r foo bar could be used. Currently the old splits of a split  archive  are  not  excluded from  a  new archive, but they can be specifically excluded.  If possible, keep the input and output archives out of the path be- ing zipped when creating split archives. Using  -s  without -sp as above creates all the splits where foo is being written, in this  case  the  current  directory.   This split  mode  updates the splits as the archive is being created, requiring all splits to remain writable, but creates  split  ar- chives  that  are  readable by any unzip that supports split ar- chives.  See -sp below for enabling split pause mode  which  al- lows splits to be written directly to removable media. The  option -sv can be used to enable verbose splitting and pro- vide details of how the splitting is being done.  The -sb option can  be used to ring the bell when zip pauses for the next split destination. Split archives cannot be updated, but see the -O (--out)  option for  how a split archive can be updated as it is copied to a new archive.  A split archive can also be converted into  a  single- file archive using a split size of 0 or negating the -s option:        zip -s 0 split.zip --out single.zip Also see -U (--copy) for more on using copy mode."
      },
      {
        "key": "split-bell",
        "title": "-sb, --split-bell",
        "description": "If  splitting and using split pause mode, ring the bell when zip pauses for each split destination."
      },
      {
        "key": "show-command",
        "title": "-sc, --show-command",
        "description": "Show the command line starting zip as processed and  exit.   The new  command  parser permutes the arguments, putting all options and any values associated with them before any non-option  argu- ments.   This allows an option to appear anywhere in the command line as long as any values that go with the option go  with  it. This  option displays the command line as zip sees it, including any arguments from the environment such as from the ZIPOPT vari- able.   Where  allowed,  options  later  in the command line can override options earlier in the command line."
      },
      {
        "key": "show-files",
        "title": "-sf, --show-files",
        "description": "Show the files that would be operated on, then  exit.   For  in- stance, if creating a new archive, this will list the files that would be added.  If the option is negated, -sf-, output only  to an  open  log file.  Screen display is not recommended for large lists."
      },
      {
        "key": "show-options",
        "title": "-so, --show-options",
        "description": "Show all available options supported by zip as compiled  on  the current  system.   As  this  command  reads the option table, it should include all options.  Each line includes the short option (if  defined),  the  long option (if defined), the format of any value that goes with the option, if the option can  be  negated, and  a small description.  The value format can be no value, re- quired value, optional value,  single  character  value,  number value,  or  a  list of values.  The output of this option is not intended to show how to use any option but only  show  what  op- tions are available."
      },
      {
        "key": "split-pause",
        "title": "-sp, --split-pause",
        "description": "If  splitting is enabled with -s, enable split pause mode.  This creates split archives as -s does, but stream writing is used so each  split  can be closed as soon as it is written and zip will pause between each split to allow changing split destination  or media. Though  this split mode allows writing splits directly to remov- able media, it uses stream archive format that may not be  read- able by some unzips.  Before relying on splits created with -sp, test a split archive with the unzip you will be using. To convert a stream split archive (created with -sp) to a  stan- dard archive see the --out option."
      },
      {
        "key": "show-unicode",
        "title": "-su, --show-unicode",
        "description": "As -sf, but also show Unicode version of the path if exists."
      },
      {
        "key": "show-just-unicode",
        "title": "-sU, --show-just-unicode",
        "description": "As  -sf,  but  only  show Unicode version of the path if exists, otherwise show the standard version of the path."
      },
      {
        "key": "split-verbose",
        "title": "-sv, --split-verbose",
        "description": "Enable various verbose messages while splitting, showing how the splitting is being done."
      },
      {
        "key": "S",
        "title": "-S, --system-hidden",
        "description": "[MSDOS, OS/2, WIN32 and ATARI] Include system and hidden files. [MacOS]  Includes finder invisible files, which are ignored oth- erwise."
      },
      {
        "key": "system-hidden",
        "title": "-S, --system-hidden",
        "description": "[MSDOS, OS/2, WIN32 and ATARI] Include system and hidden files. [MacOS]  Includes finder invisible files, which are ignored oth- erwise."
      },
      {
        "key": "t",
        "title": "-t mmddyyyy, --from-date mmddyyyy",
        "description": "Do not operate on files modified prior to  the  specified  date, where  mm  is  the  month  (00-12),  dd  is the day of the month (01-31), and  yyyy  is  the  year.   The  ISO 8601  date  format yyyy-mm-dd is also accepted.  For example:        zip -rt 12071991 infamy foo        zip -rt 1991-12-07 infamy foo will  add  all the files in foo and its subdirectories that were last modified on or after 7 December 1991, to  the  zip  archive infamy.zip."
      },
      {
        "key": "from-date",
        "title": "-t mmddyyyy, --from-date mmddyyyy",
        "description": "Do not operate on files modified prior to  the  specified  date, where  mm  is  the  month  (00-12),  dd  is the day of the month (01-31), and  yyyy  is  the  year.   The  ISO 8601  date  format yyyy-mm-dd is also accepted.  For example:        zip -rt 12071991 infamy foo        zip -rt 1991-12-07 infamy foo will  add  all the files in foo and its subdirectories that were last modified on or after 7 December 1991, to  the  zip  archive infamy.zip."
      },
      {
        "key": "before-date",
        "title": "-tt mmddyyyy, --before-date mmddyyyy",
        "description": "Do not operate on files modified after or at the specified date, where mm is the month (00-12),  dd  is  the  day  of  the  month (01-31),  and  yyyy  is  the  year.   The  ISO 8601  date format yyyy-mm-dd is also accepted.  For example:        zip -rtt 11301995 infamy foo        zip -rtt 1995-11-30 infamy foo will add all the files in foo and its subdirectories  that  were last  modified  before  30 November 1995, to the zip archive in- famy.zip."
      },
      {
        "key": "T",
        "title": "-T, --test",
        "description": "Test the integrity of the new zip file. If the check fails,  the old  zip  file  is  unchanged  and (with the -m option) no input files are removed."
      },
      {
        "key": "test",
        "title": "-T, --test",
        "description": "Test the integrity of the new zip file. If the check fails,  the old  zip  file  is  unchanged  and (with the -m option) no input files are removed."
      },
      {
        "key": "unzip-command",
        "title": "-TT cmd, --unzip-command cmd",
        "description": "Use command cmd instead of 'unzip -tqq' to test an archive  when the  -T  option is used.  On Unix, to use a copy of unzip in the current directory instead of the standard  system  unzip,  could use:  zip archive file1 file2 -T -TT \"./unzip -tqq\" In  cmd,  {}  is  replaced by the name of the temporary archive, otherwise the name of the archive is appended to the end of  the command.  The return code is checked for success (0 on Unix)."
      },
      {
        "key": "u",
        "title": "-u, --update",
        "description": "Replace (update) an existing entry in the zip archive only if it has been modified more recently than the version already in  the zip archive.  For example:        zip -u stuff * will  add any new files in the current directory, and update any files which have been modified since the zip  archive  stuff.zip was  last  created/modified  (note that zip will not try to pack stuff.zip into itself when you do this). Note that the -u option with no input file arguments  acts  like the -f (freshen) option."
      },
      {
        "key": "update",
        "title": "-u, --update",
        "description": "Replace (update) an existing entry in the zip archive only if it has been modified more recently than the version already in  the zip archive.  For example:        zip -u stuff * will  add any new files in the current directory, and update any files which have been modified since the zip  archive  stuff.zip was  last  created/modified  (note that zip will not try to pack stuff.zip into itself when you do this). Note that the -u option with no input file arguments  acts  like the -f (freshen) option."
      },
      {
        "key": "U",
        "title": "-U, --copy-entries",
        "description": "Copy  entries  from  one archive to another.  Requires the --out option to specify a different output file  than  the  input  ar- chive.   Copy  mode is the reverse of -d delete.  When delete is being used with --out, the selected entries are deleted from the archive  and  all  other  entries are copied to the new archive, while copy mode selects the files to include in the new archive. Unlike -u update, input patterns on the command line are matched against archive entries only and not the file system files.  For instance,        zip inarchive \"*.c\" --copy --out outarchive copies  entries  with  names ending in .c from inarchive to out- archive.  The wildcard must be escaped on some systems  to  pre- vent  the  shell  from substituting names of files from the file system which may have no relevance to the  entries  in  the  ar- chive. If  no input files appear on the command line and --out is used, copy mode is assumed:        zip inarchive --out outarchive This is useful for changing split size for instance.  Encrypting and  decrypting  entries  is  not yet supported using copy mode. Use zipcloak for that."
      },
      {
        "key": "copy-entries",
        "title": "-U, --copy-entries",
        "description": "Copy  entries  from  one archive to another.  Requires the --out option to specify a different output file  than  the  input  ar- chive.   Copy  mode is the reverse of -d delete.  When delete is being used with --out, the selected entries are deleted from the archive  and  all  other  entries are copied to the new archive, while copy mode selects the files to include in the new archive. Unlike -u update, input patterns on the command line are matched against archive entries only and not the file system files.  For instance,        zip inarchive \"*.c\" --copy --out outarchive copies  entries  with  names ending in .c from inarchive to out- archive.  The wildcard must be escaped on some systems  to  pre- vent  the  shell  from substituting names of files from the file system which may have no relevance to the  entries  in  the  ar- chive. If  no input files appear on the command line and --out is used, copy mode is assumed:        zip inarchive --out outarchive This is useful for changing split size for instance.  Encrypting and  decrypting  entries  is  not yet supported using copy mode. Use zipcloak for that."
      },
      {
        "key": "unicode",
        "title": "-UN v, --unicode v",
        "description": "Determine what zip should do with Unicode file names.   zip 3.0, in  addition  to  the standard file path, now includes the UTF-8 translation of the path if the entry path is not entirely  7-bit ASCII.   When  an entry is missing the Unicode path, zip reverts back to the standard file path.   The  problem  with  using  the standard  path is this path is in the local character set of the zip that created the entry, which may  contain  characters  that are  not  valid  in  the  character set being used by the unzip. When zip is reading an archive, if an entry also has  a  Unicode path, zip now defaults to using the Unicode path to recreate the standard path using the current local character set. This option can be used to determine what  zip  should  do  with this  path  if  there  is a mismatch between the stored standard path and the stored UTF-8 path (which can happen if the standard path  was  updated).  In all cases, if there is a mismatch it is assumed that the standard path is  more  current  and  zip  uses that.  Values for v are        q - quit if paths do not match        w - warn, continue with standard path        i - ignore, continue with standard path        n - no Unicode, do not use Unicode paths The default is to warn and continue. Characters  that  are not valid in the current character set are escaped as #Uxxxx and #Lxxxxxx, where x is  an  ASCII  character for a hex digit.  The first is used if a 16-bit character number is sufficient to represent the Unicode character and the  second if  the character needs more than 16 bits to represent it's Uni- code character code.  Setting -UN to        e - escape as in        zip archive -sU -UN=e forces zip to escape all characters that are not printable 7-bit ASCII. Normally zip stores UTF-8 directly in the standard path field on systems where UTF-8 is the current character set and stores  the UTF-8 in the new extra fields otherwise.  The option        u - UTF-8 as in        zip archive dir -r -UN=UTF8 forces  zip  to store UTF-8 as native in the archive.  Note that storing UTF-8 directly is the default on Unix systems that  sup- port  it.   This option could be useful on Windows systems where the escaped path is too large to be a valid path and  the  UTF-8 version of the path is smaller, but native UTF-8 is not backward compatible on Windows systems."
      },
      {
        "key": "v",
        "title": "-v, --verbose",
        "description": "Verbose mode or print diagnostic version info. Normally, when applied to real operations, this  option  enables the  display of a progress indicator during compression (see -dd for more on dots) and requests  verbose  diagnostic  info  about zipfile structure oddities. However,  when -v is the only command line argument a diagnostic screen is printed instead.  This should now work even if  stdout is redirected to a file, allowing easy saving of the information for sending with bug reports to Info-ZIP.   The  version  screen provides  the help screen header with program name, version, and release date, some pointers to the Info-ZIP home  and  distribu- tion  sites,  and shows information about the target environment (compiler type and version, OS version, compilation date and the enabled optional features used to create the zip executable)."
      },
      {
        "key": "verbose",
        "title": "-v, --verbose",
        "description": "Verbose mode or print diagnostic version info. Normally, when applied to real operations, this  option  enables the  display of a progress indicator during compression (see -dd for more on dots) and requests  verbose  diagnostic  info  about zipfile structure oddities. However,  when -v is the only command line argument a diagnostic screen is printed instead.  This should now work even if  stdout is redirected to a file, allowing easy saving of the information for sending with bug reports to Info-ZIP.   The  version  screen provides  the help screen header with program name, version, and release date, some pointers to the Info-ZIP home  and  distribu- tion  sites,  and shows information about the target environment (compiler type and version, OS version, compilation date and the enabled optional features used to create the zip executable)."
      },
      {
        "key": "V",
        "title": "-V, --VMS-portable",
        "description": "[VMS]  Save VMS file attributes.  (Files are  truncated at EOF.) When a -V archive is unpacked on a non-VMS  system,   some  file types  (notably  Stream_LF  text  files   and  pure binary files like fixed-512) should be extracted intact.  Indexed  files  and file  types  with embedded record sizes (notably variable-length record types) will probably be seen as corrupt elsewhere."
      },
      {
        "key": "VMS-portable",
        "title": "-V, --VMS-portable",
        "description": "[VMS]  Save VMS file attributes.  (Files are  truncated at EOF.) When a -V archive is unpacked on a non-VMS  system,   some  file types  (notably  Stream_LF  text  files   and  pure binary files like fixed-512) should be extracted intact.  Indexed  files  and file  types  with embedded record sizes (notably variable-length record types) will probably be seen as corrupt elsewhere."
      },
      {
        "key": "VMS-specific",
        "title": "-VV, --VMS-specific",
        "description": "[VMS] Save VMS file attributes, and  all allocated blocks  in  a file,   including  any  data beyond EOF.  Useful for moving ill- formed files  among  VMS systems.   When a -VV  archive  is  un- packed  on  a  non-VMS system, almost all files will appear cor- rupt."
      },
      {
        "key": "w",
        "title": "-w, --VMS-versions",
        "description": "[VMS] Append the version number of the files to  the  name,  in- cluding  multiple versions of files.  Default is to use only the most recent version of a specified file."
      },
      {
        "key": "VMS-versions",
        "title": "-w, --VMS-versions",
        "description": "[VMS] Append the version number of the files to  the  name,  in- cluding  multiple versions of files.  Default is to use only the most recent version of a specified file."
      },
      {
        "key": "VMS-dot-versions",
        "title": "-ww, --VMS-dot-versions",
        "description": "[VMS] Append the version number of the files to  the  name,  in- cluding  multiple versions of files, using the .nnn format.  De- fault is to use only the most  recent  version  of  a  specified file."
      },
      {
        "key": "wild-stop-dirs",
        "title": "-ws, --wild-stop-dirs",
        "description": "Wildcards match only at a directory level.  Normally zip handles paths as strings and given the paths        /foo/bar/dir/file1.c        /foo/bar/file2.c an input pattern such as        /foo/bar/* normally would match both paths, the * matching dir/file1.c  and file2.c.   Note  that in the first case a directory boundary (/) was crossed in the match.  With -ws no directory bounds will  be included  in the match, making wildcards local to a specific di- rectory level.  So, with -ws enabled, only the second path would be matched. When using -ws, use ** to match across directory boundaries as * does normally."
      },
      {
        "key": "x",
        "title": "-x files, --exclude files",
        "description": "Explicitly exclude the specified files, as in:        zip -r foo foo -x \\*.o which will include the contents of foo in foo.zip while  exclud- ing  all  the  files  that  end in .o.  The backslash avoids the shell filename substitution, so that the name matching  is  per- formed by zip at all directory levels. Also possible:        zip -r foo foo -x@exclude.lst which  will include the contents of foo in foo.zip while exclud- ing all the files that  match  the  patterns  in  the  file  ex- clude.lst. The long option forms of the above are        zip -r foo foo --exclude \\*.o and        zip -r foo foo --exclude @exclude.lst Multiple patterns can be specified, as in:        zip -r foo foo -x \\*.o \\*.c If  there is no space between -x and the pattern, just one value is assumed (no list):        zip -r foo foo -x\\*.o See -i for more on include and exclude."
      },
      {
        "key": "exclude",
        "title": "-x files, --exclude files",
        "description": "Explicitly exclude the specified files, as in:        zip -r foo foo -x \\*.o which will include the contents of foo in foo.zip while  exclud- ing  all  the  files  that  end in .o.  The backslash avoids the shell filename substitution, so that the name matching  is  per- formed by zip at all directory levels. Also possible:        zip -r foo foo -x@exclude.lst which  will include the contents of foo in foo.zip while exclud- ing all the files that  match  the  patterns  in  the  file  ex- clude.lst. The long option forms of the above are        zip -r foo foo --exclude \\*.o and        zip -r foo foo --exclude @exclude.lst Multiple patterns can be specified, as in:        zip -r foo foo -x \\*.o \\*.c If  there is no space between -x and the pattern, just one value is assumed (no list):        zip -r foo foo -x\\*.o See -i for more on include and exclude."
      },
      {
        "key": "X",
        "title": "-X, --no-extra",
        "description": "Do not save extra file attributes (Extended Attributes on  OS/2, uid/gid  and  file  times  on  Unix).  The zip format uses extra fields to include additional information for each  entry.   Some extra fields are specific to particular systems while others are applicable to all systems.  Normally when zip reads entries from an  existing archive, it reads the extra fields it knows, strips the rest, and adds the extra fields applicable to  that  system. With -X, zip strips all old fields and only includes the Unicode and Zip64 extra fields (currently these two extra fields  cannot be disabled). Negating  this  option,  -X-,  includes  all  the  default extra fields, but also copies over any unrecognized extra fields."
      },
      {
        "key": "no-extra",
        "title": "-X, --no-extra",
        "description": "Do not save extra file attributes (Extended Attributes on  OS/2, uid/gid  and  file  times  on  Unix).  The zip format uses extra fields to include additional information for each  entry.   Some extra fields are specific to particular systems while others are applicable to all systems.  Normally when zip reads entries from an  existing archive, it reads the extra fields it knows, strips the rest, and adds the extra fields applicable to  that  system. With -X, zip strips all old fields and only includes the Unicode and Zip64 extra fields (currently these two extra fields  cannot be disabled). Negating  this  option,  -X-,  includes  all  the  default extra fields, but also copies over any unrecognized extra fields."
      },
      {
        "key": "y",
        "title": "-y, --symlinks",
        "description": "For UNIX and VMS (V8.3 and later), store symbolic links as  such in  the zip archive, instead of compressing and storing the file referred to by the link.  This  can  avoid  multiple  copies  of files  being  included in the archive as zip recurses the direc- tory trees and accesses files directly and by links."
      },
      {
        "key": "symlinks",
        "title": "-y, --symlinks",
        "description": "For UNIX and VMS (V8.3 and later), store symbolic links as  such in  the zip archive, instead of compressing and storing the file referred to by the link.  This  can  avoid  multiple  copies  of files  being  included in the archive as zip recurses the direc- tory trees and accesses files directly and by links."
      },
      {
        "key": "z",
        "title": "-z, --archive-comment",
        "description": "Prompt for a multi-line comment for the entire zip archive.  The comment  is  ended by a line containing just a period, or an end of file condition (^D on Unix, ^Z on MSDOS, OS/2, and VMS).  The comment can be taken from a file:        zip -z foo < foowhat"
      },
      {
        "key": "archive-comment",
        "title": "-z, --archive-comment",
        "description": "Prompt for a multi-line comment for the entire zip archive.  The comment  is  ended by a line containing just a period, or an end of file condition (^D on Unix, ^Z on MSDOS, OS/2, and VMS).  The comment can be taken from a file:        zip -z foo < foowhat"
      },
      {
        "key": "Z",
        "title": "-Z cm, --compression-method cm",
        "description": "Set  the default compression method.  Currently the main methods supported by zip are store and deflate.  Compression method  can be set to: store  -  Setting  the compression method to store forces zip to store entries with no compression.   This  is  generally  faster than compressing entries, but results in no space savings.  This is the same as using -0 (compression level zero). deflate - This is the default method for zip.  If zip determines that  storing is better than deflation, the entry will be stored instead. bzip2 - If bzip2 support is compiled in, this compression method also  becomes available.  Only some modern unzips currently sup- port the bzip2 compression method, so test the unzip you will be using  before relying on archives using this method (compression method 12). For example, to add bar.c to archive foo  using  bzip2  compres- sion:        zip -Z bzip2 foo bar.c The compression method can be abbreviated:        zip -Zb foo bar.c"
      },
      {
        "key": "compression-method",
        "title": "-Z cm, --compression-method cm",
        "description": "Set  the default compression method.  Currently the main methods supported by zip are store and deflate.  Compression method  can be set to: store  -  Setting  the compression method to store forces zip to store entries with no compression.   This  is  generally  faster than compressing entries, but results in no space savings.  This is the same as using -0 (compression level zero). deflate - This is the default method for zip.  If zip determines that  storing is better than deflation, the entry will be stored instead. bzip2 - If bzip2 support is compiled in, this compression method also  becomes available.  Only some modern unzips currently sup- port the bzip2 compression method, so test the unzip you will be using  before relying on archives using this method (compression method 12). For example, to add bar.c to archive foo  using  bzip2  compres- sion:        zip -Z bzip2 foo bar.c The compression method can be abbreviated:        zip -Zb foo bar.c"
      },
      {
        "key": "use-privileges",
        "title": "-!, --use-privileges",
        "description": "[WIN32]  Use  priviliges  (if  granted) to obtain all aspects of WinNT security."
      },
      {
        "key": "names-stdin",
        "title": "-@, --names-stdin",
        "description": "Take the list of input files from standard input. Only one file- name per line."
      },
      {
        "key": "volume-label",
        "title": "-$, --volume-label",
        "description": "[MSDOS,  OS/2,  WIN32]  Include  the  volume label for the drive holding the first file to be compressed.  If you want to include only  the  volume  label  or  to force a specific drive, use the drive name as first file name, as in:        zip -$ foo a: c:bar"
      }
    ]
  }
]
